загрузка имеджа:
docker run -p 61616:61616 -p 8161:8161 apache/activemq-classic

урл для ActtiveMQ: http://localhost:8161/index.html
    user: admin
    password: admin
Запросы пример:
    POST "http://localhost:8080/queue?message=TestQueueMessage"
Log:
    2025-09-30T12:33:55.202+03:00  INFO 29672 --- [nio-8080-exec-6] com.epam.activemqdemo.jms.Producer       : Sending message TestQueueMessage to  queue - simple-queue
    2025-09-30T12:33:55.216+03:00  INFO 29672 --- [ntContainer#0-1] c.epam.activemqdemo.jms.QueueListener    : Received message: TestQueueMessage from queue - simple-queue

    POST "http://localhost:8080/topic?message=TestTopicMessage"
Log:
    2025-09-30T12:34:49.457+03:00  INFO 29672 --- [nio-8080-exec-5] com.epam.activemqdemo.jms.Publisher      : Sending message TestTopicMessage to  topic - simple-topic
    2025-09-30T12:34:49.472+03:00  INFO 29672 --- [ntContainer#2-1] c.epam.activemqdemo.jms.TopicListener2   : Received message: TestTopicMessage from topic - simple-topic by subscriber 2.
    2025-09-30T12:34:49.472+03:00  INFO 29672 --- [ntContainer#1-1] c.epam.activemqdemo.jms.TopicListener1   : Received message: TestTopicMessage from topic - simple-topic by subscriber 1.

************************************************
"Хорошо, пользователь изучает Spring и ActiveMQ и предоставил код приложения. Он явно новичок в теме брокеров сообщений и хочет понять базовые принципы. Нужно объяснить максимально доступно, без излишней сложности.
Сначала стоит описать общую архитектуру приложения: какие компоненты есть и какую роль каждый играет. Затем объяснить концепцию брокера сообщений и ActiveMQ, чтобы пользователь понял контекст.
Важно выделить ключевые различия между очередями и топиками, так как это центральный момент в его коде. Нужно показать, как конфигурируются подключения, отправка и получение сообщений в Spring, и как это связано с ActiveMQ.
Лучше использовать аналогии, например, почтовое отделение для брокера, чтобы сделать объяснение наглядным. Также стоит упомянуть практическое применение таких систем, чтобы пользователь видел ценность изученного.
Ответ должен быть структурированным, но не слишком техническим, чтобы не перегружать новичка. Можно разбить его на логические блоки: общее описание, компоненты, объяснение очередей и топиков, процесс работы, практическое применение."
************************************************
Отличный вопрос! Вы предоставили полноценное Spring Boot приложение для работы с очередями и топиками ActiveMQ. Давайте разберем его по косточкам. Я постараюсь объяснить все максимально подробно и просто, как если бы вы только начали изучать эту тему.

1. Общая концепция: Что такое брокер сообщений (ActiveMQ) и зачем он нужен?
Представьте себе почтовое отделение.
 - Ваше приложение (Producer/Publisher) — это отправитель письма.
 - Брокер сообщений (ActiveMQ) — это само почтовое отделение, которое принимает, хранит и сортирует письма.
 - Другое ваше приложение (Listener/Consumer) — это получатель письма, который приходит в отделение за своей посылкой.
 - Асинхронность: Отправитель (ваш REST-контроллер) может "бросить" сообщение в брокер и сразу же вернуть ответ клиенту, не дожидаясь, пока получатель его обработает. Получатель обработает его тогда, когда сможет.
 - Связность (Decoupling): Отправитель и получатель ничего не знают друг о друге. Они знают только "адрес" (название очереди/топика) в брокере. Это позволяет независимо обновлять и масштабировать разные части системы.
 - Надежность: Брокер гарантирует, что сообщение будет доставлено. Если получатель "упал", сообщение будет храниться в очереди до тех пор, пока получатель не поднимется снова.
 - Масштабируемость: Можно легко запустить несколько экземпляров получателей для обработки сообщений из одной очереди.

ActiveMQ — это конкретная реализация такого брокера сообщений, которая понимает протокол JMS (Java Message Service). JMS — это API, стандарт для работы с сообщениями в Java. Ваше приложение использует Spring-обертки над JMS для удобства.

2. Архитектура вашего приложения
Ваше приложение состоит из нескольких ключевых частей:
 - JmsConfig: Конфигурационный класс, который "объясняет" Spring'у, как работать с ActiveMQ.
 - JmsController: Точка входа извне (через HTTP). Принимает сообщения от пользователя и решает, куда их отправить.
 - Producer & Publisher: Классы, ответственные за отправку сообщений в очередь и топик соответственно.
 - QueueListener, TopicListener1, TopicListener2: Классы, которые слушают (получают и обрабатывают) сообщения из очереди и топика.
 - ActivemqApplication: Главный класс, который запускает все приложение.
 - application.yml: Файл конфигурации, где хранятся настройки (адрес брокера, логины, названия очередей).

3. Детальный разбор компонентов
 3.1)JmsConfig — Сердце конфигурации
 Этот класс создает все необходимые "инструменты" для работы с JMS.
 - ActiveMQConnectionFactory: Фабрика, которая создает подключения к брокеру ActiveMQ. Она использует параметры из application.yml (broker-url, user, password)
 - Два JmsTemplate:
    - queueJmsTemplate: Используется для отправки сообщений в очередь (Queue). Ключевая настройка — pubSubDomain=false (по умолчанию).
    - topicJmsTemplate: Используется для отправки сообщений в топик (Topic). Ключевая настройка — template.setPubSubDomain(true);.
 - Два DefaultJmsListenerContainerFactory
    - queueListenerFactory: Создает контейнеры для слушателей (Listener'ов), которые будут слушать очереди.
    - topicListenerFactory: Создает контейнеры для слушателей, которые будут слушать топики. Ключевая настройка — factory.setPubSubDomain(true);.
 Почему два разных шаблона и две разные фабрики? Потому что модели доставки для очередей и топиков в JMS fundamentally разные! Spring должен знать, к чему он подключается.

 3.2)Producer и Publisher — Отправители
  - Producer внедряет @Qualifier("queueJmsTemplate") JmsTemplate. Это значит, что он использует именно тот бин, который настроен для работы с очередями. Его метод sendMessageToQueue использует этот шаблон, чтобы отправить сообщение в очередь с именем simple-queue.
  - Publisher внедряет @Qualifier("topicJmsTemplate") JmsTemplate, настроенный для топиков. Его метод sendMessageToTopic отправляет сообщение в топик с именем simple-topic.
  Оба они вызывают jmsTemplate.convertAndSend(destinationName, message). Этот метод автоматически преобразует ваш объект (в данном случае String) в JMS-сообщение и отправляет его.

 3.3)QueueListener, TopicListener1, TopicListener2 — Получатели
  - Аннотация @JmsListener — это волшебная аннотация Spring. Она говорит: "Настрой меня как получателя сообщений из указанного места (destination) используя указанную фабрику (containerFactory)".
  - QueueListener:
    - destination = "${activemq.queue}" -> слушает очередь simple-queue.
	- containerFactory = "queueListenerFactory" -> использует фабрику для очередей.
	- Важно: Сообщение из очереди будет доставлено только одному слушателю. Если бы у вас было два QueueListener, работающих одновременно, сообщения распределились бы между ними (конкурирующие потребители).
  - TopicListener1 и TopicListener2:
    - Оба слушают один и тот же топик simple-topic.
	- Оба используют containerFactory = "topicListenerFactory" (с включенным pubSubDomain).
	- Важно: В модели "Pub/Sub" (Publisher-Subscriber) сообщение, отправленное в топик, получают ВСЕ активные на тот момент подписчики. Оба ваших listener'а получат копию одного и того же сообщения.
 3.4) JmsController — HTTP Интерфейс
 Простой REST-контроллер, который предоставляет два endpoint'а:
  - POST /queue?message=Hello -> вызывает Producer, который отправляет сообщение в очередь.
  - POST /topic?message=Hello -> вызывает Publisher, который отправляет сообщение в топик.
 Это триггер, который запускает весь процесс.

4. Как происходит взаимодействие? (Практический пример)
  Шаг 0: Предварительные условия
  0.1) Запущен брокер ActiveMQ на localhost:61616 (обычно скачивается и запускается файлом activemq start).
  0.2) Запущено ваше Spring Boot приложение.

  Сценарий 1: Отправка в очередь (/queue)
   1)Вы делаете HTTP-запрос: POST http://localhost:8080/queue?message=MyFirstMessage
   2)JmsController вызывает producer.sendMessageToQueue("MyFirstMessage").
   3)Producer берет queueJmsTemplate и отправляет сообщение в очередь simple-queue.
   4)Активный QueueListener видит, что в очереди simple-queue появилось новое сообщение.
   5)QueueListener получает это сообщение, логирует его: "Received message: MyFirstMessage from queue - simple-queue".
   6)Сообщение удаляется из очереди.

  Сценарий 2: Отправка в топик (/topic)
   1)Вы делаете HTTP-запрос: POST http://localhost:8080/topic?message=MyTopicMessage
   2)JmsController вызывает publisher.sendMessageToTopic("MyTopicMessage").
   3)Publisher берет topicJmsTemplate и отправляет сообщение в топик simple-topic.
   4)ActiveMQ видит, что на этот топик подписаны два слушателя: TopicListener1 и TopicListener2.
   5)ActiveMQ создает две копии сообщения и отправляет каждому из них.
   6)TopicListener1 логирует: "Received message: MyTopicMessage from topic - simple-topic by subscriber 1.".
   7)TopicListener2 логирует: "Received message: MyTopicMessage from topic - simple-topic by subscriber 2.".

5. Ключевые различия: Очередь (Queue) vs Топик (Topic)
Характеристика	  Очередь (Queue)	                                   Топик (Topic)
Модель	          Point-to-Point	                                   Publish-Subscribe (Pub/Sub)
Доставка	      Сообщение получает только один потребитель	       Сообщение получают все активные подписчики
Назначение	      Распределение задач между работниками	               Широковещательные уведомления, события
Связь	          Отправитель и получатель не зависят друг от друга	   Отправитель не знает о подписчиках